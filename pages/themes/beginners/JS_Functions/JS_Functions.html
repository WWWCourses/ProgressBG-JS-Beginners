<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>JS - Функции</title>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	<!-- css & themes include -->
	<link rel="stylesheet" href="../../../../lib/reveal.js/css/reveal.css">
	<link rel="stylesheet" href="../../../../outfit/css/themes/light.css" id="theme">
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? '../../../../lib/reveal.js/css/print/pdf.css' : '../../../../lib/reveal.js/css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
	<!-- CUSTOM -->
	<base target="_blank">
</head>
<body>
	<div class="reveal default center" data-transition-speed="default" data-background-transition="default">
		<div class="top_links">
			<a class="home_link" href="../../../../pages/agenda/beginners.html#JS_Functions" target="_top"><i class="fa fa-home"></i></a>
			<span class="help_link"><i class="fa fa-question"></i></span>
			<div class="help_text">
				<div><span>N/Спейс</span><span>следващ слайд</span></div>
				<div><span>P</span><span>предишен слайд</span></div>
				<div><span>O</span><span>всички слайдове</span></div>
				<div><span>ctrl+left click</span><span>увеличава елемента</span></div>
			</div>
		</div>
		<div class="footer theme_switch">
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../../outfit/css/themes/dark.css'); return false;">Dark</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../../outfit/css/themes/light.css'); return false;">Light</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../../outfit/css/themes/projector.css'); return false;">Projector</a>
		</div>
		<div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section><h1>Функции в JavaScript</h1></section>
<section data-transition="zoom">
	<section>
		<div class="copyright">
			<div class="note">
				<p>Created for</p>
			</div>
			<div class="company">
				<a href="http://progressbg.net/kurs-po-web-design/">
				<img src="../../../../outfit/images/logos/ProgressBG_logo_529_127.png">
				</a>
			</div>
		</div>
	</section>
	<section class="copyright" data-transition="zoom" style="margin-top: -2em;">
		<div class="note">
			<p>Created by</p>
		</div>
		<div class="company">
		   <div class="LI-profile-badge"  data-version="v1" data-size="large" data-locale="en_US" data-type="vertical" data-theme="dark" data-vanity="ivapopova"><a class="LI-simple-link" href='https://bg.linkedin.com/in/ivapopova?trk=profile-badge'>Iva E. Popova</a></div>
		</div>
		<div class="author">
			<span class="date">2015 - 2020, </span>
			<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="../../../../images/creativecommons.org_l_by-sa_4.0_88x31.png"></a>
		</div>
	</section>
</section>


<section><h1>Въведение</h1></section>
<section><h2>Въведение</h2>
	<section>
		<blockquote>"Really understanding functions in JavaScript is the single most important weapon you can wield"</blockquote>
		<cite><a href="https://www.manning.com/books/secrets-of-the-javascript-ninja-second-edition">
		<em>"Secrets of the JavaScript Ninja"</em><br>
		<small>©2016 by Manning Publications Co</small></a></cite>
	</section>
	<section><h3>Какво са функциите?</h3>
		<dl class="fa">
			<dt>Последователност от действия изпълняващи дадена задача, които обединяваме под общо име</dt>
			<dd>Пример: кулинарна рецепта</dd>
			<dt>Действията се изпълняват след указване на името а резултата може да зависи от допълнителни параметри.</dt>
			<dd><q class="note">"Скъпи, направи палачинки"</q> vs. <q class="note">"Мамо, направи палачинки"</q> </dd>
		</dl>
	</section>
	<section><h3>Защо да използваме функции?</h3>
		<dl class="fa">
			<dt>Отделяне на концептуално свързани действия в едно цяло</dt>
			<dt>Избягваме повторението на код (DRY принцип)</dt>
			<dt>По-добро структуриране на програмата</dt>
			<dt>Увеличават изразителната сила на езика</dt>
		</dl>
	</section>
</section>

<section id="function_basics"><h1>Дефиниция на функция (<a href="https://www.w3schools.com/js/js_function_definition.asp">Function Definition</a>)</h1></section>
<section><h2>Дефиниция на функция (<a href="https://www.w3schools.com/js/js_function_definition.asp">Function Definition</a>)</h2>
	<section><h3>Вариант 1: Function Declarations</h3>
		<pre><code rel="Syntax">
			function &lt;име&gt;( &lt;списък параметри&gt; ) {
				&lt;тяло на функцията&gt;
			}
		</code></pre>
		<dl class="fa" style="font-size: .9em;">
			<dt><code>&lt;име&gt;</code></dt>
			<dd>Име на функцията, съобразено с <a href="https://developer.mozilla.org/en-US/docs/Glossary/Identifier">правилата за идентификатори в JS</a>. (<a href="https://mothereff.in/js-variables#%E0%B2%A0%5f%E0%B2%A0">tool:   variable name validator</a>)</dd>
			<dt><code>&lt;списък параметри&gt;</code></dt>
			<dd>Нула или повече параметъра разделени със запетая. Кръглите скоби са задължителни дори и ако функцията няма параметри. </dd>
			<dt><code>&lt;тяло на функцията&gt;</code></dt>
			<dd>Изрази, разделени с '<code>;</code>'</dd>
			<dt>Забележете, че след декларацията на функцията не e необходимо да се слага ';', <b>но не пречи</b>!</dt>
		</dl>
	</section>
	<section><h3>Function Declarations - Примери</h3>
		<pre><code rel="JavaScript">
			//функцията няма параметри
			function signOutMsg(){
				confirm("Прекратяване на сесията?");
			}
		</code></pre>
		<br>
		<pre><code rel="JavaScript">
			// функцията декларира 2 параметъра
			function sum(x, y){
				console.log( x + y );
			}
		</code></pre>
	</section>
	<section><h3>Вариант 2: Function Expression</h3>
		<pre><code rel="Syntax">
			var functionVar = function(&lt;списък параметри&gt;){
				&lt;тяло на функцията&gt;
			};
		</code></pre>
		<dl class="fa">
		<dt>Тук се създава анонимна функция, която е достъпна чрез променливата <code>functionVar</code> в която сме я съхранили.</dt>
		<dt>Реално, се извършват две действия:</dt>
		<dd>1. var functionVar = undefined <span class="note">// compile time</span></dd>
		<dd>2. functionVar = function(...){...}; <span class="note">// run time</span>
		</dd>
		<dt>Тъй като тук дефинираме функцията чрез израз (оператора за присвояване), то задължително трябва да сложим '<span class="note">;</span>' в края.</dt>
		</dl>
	</section>
	<section><h3>Параметри на функция</h3>
		<dl class="fa">
			<dt>Параметрите на една функция са <span class="note">локални променливи</span> които <b>не декларираме</b> експлицитно с <code>var</code> или <code>let</code>.</dt>
			<dt>Имената на параметри трябва да отговарят на правилата за именуване на променливи в JavaScript.</dt>
			<dt>Параметрите получават стойност при извикването (изпълнението) на функцията.</dt>
		</dl>
	</section>
</section>

<section><h1>извикване на функция (Function Invocation)</h1></section>
<section><h2>Function Invocation</h2>
	<section>
		<dl class="fa">
			<dt>За да се изпълнят действията зададени в една функция, то тя трябва да се "извика".</dt>
			<dt>Синоними:</dt>
			<dd>Извикване, стартиране, изпълнение на функция</dd>
			<dd>Function <span class="note">call</span>, <span class="note">invocation</span>, <span class="note">execution</span>.</dd>
		</dl>
	</section>
	<section><h3>Синтаксис</h3>
		<pre><code rel="Syntax">
			name(&lt;списък аргументи&gt;);
		</code></pre>
		<dl class="fa">
			<dt>name</dt>
			<dd>името на функцията, която желаем да изпълним.</dd>
			<dt>&lt;списък аргументи&gt;</dt>
			<dd>стойности, които автоматично ще се подадат на параметрите.</dd>
			<dt>Между името на функцията и отварящата скоба '(' не се оставя спейс!</dt>
		</dl>
	</section>
	<section><h3>Пример</h3>
		<pre><code rel="JS" class="js">
			function greet(userName){
				console.log(`Hello ${userName}. Nice to see you.`);
			}

			// едва при извикването ще се изпълнят действията, дефинирани във фунцкцията

			// извикаване на функцията greet() с аргумент "Ada"
			greet("Ada");
			// извикаване на функцията greet() с аргумент "John"
			greet("John");
		</code></pre>
	</section>
	<section><h3>Предаване на аргументи</h3>
		<dl class="fa">
			<dd>Съпоставянето (предаването) на стойности между параметър и аргумент е в зависимост от последователността на изписване. Тоест - <span class="note">първия параметър приема стойността на първия аргумент, втория параметър - на втория аргумент и т.н</span></dd>
		</dl>
	</section>
	<section><h3>Предаване на аргументи</h3>
		<img src="images/argument-parameters mapping.png" alt="argument-parameters mapping"><br>
		<ul>
			<li>x = 2</li>
			<li>y = 3</li>
		</ul>
	</section>
	<section><h3>Предаване на аргументи</h3>
		<pre><code rel="JS">
			// декларация на функцията sum():
			function sum(x, y){
				// var x = 2, y = 3;
				console.log( x + y);
			}

			// извикване на функцията sum():
			sum(2, 3); // 5
		</code></pre>
		<p>при предаването на стойности на параметрите, това което JS интерпретатора прави, е да създаде локални променливи и да им присвои стойностите зададени в аргументите.</p>
	</section>
	<section><h3>Особености</h3>
		<dl class="fa">
			<dt>Ако борят на параметрите не съответства на броя на аргументите, JavaScript не връща грешка!</dt>
		</dl>
		<pre style="width: 100%; font-size: .5em;"><code rel="JS">
			function sum(x, y){
				// var x = 2, y = undefined;
				console.log( x + y);
			}

			sum(2); // NaN
		</code></pre>
		<pre style="width: 100%; font-size: .5em;"><code rel="JS">
			function sum(x){
				// var x = 2;
				console.log( x ); // 2
				console.log( x + y); // ReferenceError: y is not defined
				// ако не използваме y във функцията, няма да има грешка.
			}

			sum(2, 3);
		</code></pre>
	</section>
</section>

<section><h1>Return Statement</h1></section>
<section><h2>Return Statement</h2>
	<section>
		<dl class="fa">
			<dt class="note">Всяка функция в JavaScript връща стойност.</dt>
			<dt>На мястото на извикването на функцията ще се подаде връщаната от функцията стойност.</dt>
			<dt>За да определим каква да бъде връщаната стойност използваме оператора <code class="note">return</code></dt>
			<dt>Ако във функцията не сме използвали оператора <code class="note">return</code>, то функцията връща <code class="note">undefined</code>!</dt>
		</dl>
	</section>
	<section>
		<pre><code rel="Syntax">
			function f(){
				// some code
				return <израз>; // exit
			}

			let res = f();
		</code></pre>
		<dl class="fa">
			<dt><израз>  трябва да бъде изчислим.</dt>
			<dt>Именно изчислената стойност ще се замести на мястото на извикване на функцията</dt>
			<dt><span class="note">След оператора <code>return</code> се излиза от тялото на функцията</span>. Тоест, нито един израз във функцията, след <code>return</code> няма да се изпълни! </dt>
		</dl>
	</section>
	<section><h3>Example</h3>
		<pre><code rel="JS">
			function f(){
				console.log("start");
				return true;
				console.log("end"); // никога няма да се изпълни!
			}

			f();

			// "start"
		</code></pre>
	</section>
	<section><h3>Пример</h3>
		<pre><code rel="JS" class="js">
			function giveMeAnswer(){
				console.log("and the answer is...");
				return 42;
			}

			// giveMeAnswer() ще се замести с 42:
			console.log( giveMeAnswer() );

			// and the answer is...
			// 42
		</code></pre>
	</section>
</section>

<section id="Scope"><h1>Обхват на променливите (Variables Scope)</h1></section>
<section><h2>Обхват на променливите (Variables Scope)</h2>
	<section><h3>Въведение</h3>
		<dl class="fa">
			<dt>Обхват (scope) на една променлива наричаме областта от кода, в която може да достъпим дадената променлива.</dt>
			<dt>В JavaScript различаваме 2 вида scope:</dt>
			<dd><span class="note">global</span></dd>
			<dd><span class="note">local</span></dd>
			<dd>*ES6 въвежда и <span class="note">block</span> scope (чрез <code>let</code> и <code>const</code>), разгледан в следвашите слайдове.</dd>
		</dl>
	</section>
	<section><h3>Local Scope</h3>
		<dl class="fa" style="font-size: .9em">
			<dt>Тялото на всяка една функция формира <span class="note">local scope.</span></dt>
			<dt>Всяка променлива, декларирана с <span class="note">var, let или const</span>, в тялото на една функция се нарича <span class="note">локална</span> и е видима само в тялото на функцията (не може да бъде достъпена извън тялото на функцията)</dt>
		</dl>
		<pre><code rel="JS">
			function f(){
				// firstName e локална за f():
				var firstName = "ada";

				console.log( firstName );
			}

			f(); // "ada"
			console.log( firstName ); // ReferenceError: firstName is not defined
		</code></pre>
	</section>
	<section><h3>Global Scope</h3>
		<dl class="fa">
			 <dt>Когато скрипта се изпълнява от браузър, глобалният обхват (<span class="note">global scope</span>) е всичкия код принадлежащ към дадената страница. Ако имаме няколко включени в дадена страница, то всички те формират global scope.</dt>
			<dt>Променлива, която не е декларирана в тялото на която и да е функция, се нарича <span class="note">глобална</span> и може да бъде достъпена от всяко едно място в global scope.</dt>
		</dl>
	</section>
	<section><h3>Global Scope</h3>
		<pre style="width: 110%"><code rel="lib.js" class="js">
			// x е глобална променлива
			var x = 5;
		</code></pre>
		<pre style="width: 110%"><code rel="index.html" class="js">
			&lt;body&gt;
				&lt;!-- ... --&gt;
				&lt;script type=&quot;text/javascript&quot; src=&quot;lib.js&quot;&gt;&lt;/script&gt;
				&lt;script type=&quot;text/javascript&quot;&gt;
					console.log(`x = ${x}`)
					// x = 5
				&lt;/script&gt;
			&lt;/body&gt;
		</code></pre>
	</section>
	<section><h3>Shadowing</h3>
		<img src="images/Scope1.png">
		<dl class="fa">
			<dt>Локални променливи, чието име съвпада с променливи от външния scope, припокриват, засенчват (shadowing) външните променливи в рамките на локалния scope.</dt>
		</dl>
	</section>
	<section><h3>Shadowing</h3>
		<pre><code rel="JS">
			var firstName = "Ada";

			function foo(){
				var firstName = "Turing"
				console.log("foo() firstName: ", firstName);
			}
			foo(); // "Turing"

			console.log("global firstName: ", firstName); // "Ada"
		</code></pre>
		<p>Локалната променлива firstName не променя стойността на глобалната променлива firstName!</p>
		<p>За JavaScript това са 2 отделни променливи!</p>
	</section>
	<section>
		<p>Внимавайте за следният възможен бъг:</p>
			<pre><code rel="JS">
				var firstName = "Ada";

				function foo(){
					// тук променяме глобалната променлива!!!
					firstName = "Turing"
					console.log("foo() firstName: ", firstName);
				}
				foo();

				console.log("global firstName: ", firstName);
			</code></pre>
			<p>firstName в тялото на функцията НЕ Е декларирана чрез var и така тя се счита за глобална променлива!</p>
	</section>
</section>

<section data-min="5" id="let_const_var"><h1>Разлики между <code>let</code>, <code>const</code> и <code>var</code></h1></section>
<section><h2>Разлики между <code>let</code>, <code>const</code> и <code>var</code></h2>
  <section><h3><code>let/const</code> vs. <code>var</code>: scoping</h3>
	  <dl class="fa">
		  <dt>ES6 въвежда в JavaScript и <code class="note">block scope</code> за променливи дефинирани чрез ключовите думи <code class="note">let</code> и <code class="note">const</code></dt>
		  <dd><code>block</code> е всяка част от кода между <code>{</code> и <code>}</code></dd>
	  </dl>
	  <pre><code rel="JS" class="js">
		  {
			var x = 2;           // x e глобална променлива
			let y = 4;           // y e видима само в текущия блок
			const alpha = 2.34;  // alpha e видима само в текущия блок
		  }

		  console.log(`x=${x}`);          // x=2
		  console.log(`y=${y}`);          // error: y is not defined
		  console.log(`alpha=${alpha}`);  // error: alpha is not defined
	  </code></pre>
  </section>
  <section><h3><code>let/const</code> vs. <code>var</code>: scoping - пример</h3>
	<pre><code rel="JS" class="js">
		let status = "none",
			userAge = 32;

		if(userAge>=18){
			//тук не променяме глобалната променлива status, а създаваме нова променлива видима единствено в този блок
			let status = "Adult"
		};

		console.log(`status = ${status}`);
		// status = none
	</code></pre>
  </section>
  <section><h3><code>let/const</code> vs. <code>var</code>: redeclaring</h3>
	  <dl class="fa">
		  <dt>Друга разлика между <code>let/cont</code> и <code>var</code> е че ако една променлива вече е декларирана, то при повторна декларация (redeclaring) в съшия скоуп чрез <code>let</code> или <code>const</code> ще възникне грешка.</dt>
		  <dt>При редеклариране чрез <code>var</code> нe би възникнала грешка</dt>
		  <dt class="note">Дoбра практика е да предпочитаме използването на <code>let/const</code> за деклариране на променливи, вместо <code>var</code>!</dt>
	  </dl>
  </section>
  <section><h3>Особености на <code>const</code></h3>
	<dl class="fa">
		<dt>Чрез <code>const</code> създаваме променливи, които не бихме искали да ре-дефинираме по погрешка..</dt>
		<pre><code rel="JS" class="js">
			const GOLDEN_RATIO =  1.618;
			GOLDEN_RATIO = 2; //TypeError: Assignment to constant variable.
		</code></pre>
		<dt>Променлива създадена чрез <code>const</code> задължително трябва да бъде инициализирана:</dt>
		<pre><code rel="JS" class="js">
			const GOLDEN_RATIO; // SyntaxError: Missing initializer in const declaration
		</code></pre>
	</dl>
  </section>
  <section><h3 class="advanced">Особености на <code>const</code></h3>
	<dl class="fa">
		<dt><code>const</code> не гарантира създаването на константи в буквалния смисъл. А единствено, че при опит за re-assign ще възнине грешка!</dt>
		<dt>Ако стойността на <code>const</code> променливата е съставна, т.е обект, то ние <code>можем</code> да променим някое негово пропърти без да възникне грешка</dt>
		<pre><code rel="JS" class="js">
			const someArray = [3.14];

			// тук не re-assign-ваме someАrray, а променяме стойност в самия масив
			someArray[0] = 99;
			console.log( someArray[0] ); // 99

			const someObject = {
				"pi": 3.14,
			}

			// тук не re-assign-ваме someObject, а променяме пропърти в самия обект:
			someObject.pi = 4;
			console.log( someObject.pi ); // 4

			// тук правим опит за re-assign:
			someArray = 4;      // TypeError: Assignment to constant variable.
			someObject = {};    // TypeError: Assignment to constant variable.
		</code></pre>
	</dl>
  </section>

</section>

<section><h1>Анонимни функции (Anonymous functions)</h1></section>
<section><h2>Анонимни функции</h2>
	<section>
		<dl class="fa">
			<dt>Функция, която няма име се нарича анонимна функция!</dt>
			<dt>Обикновено, анонимните функции се използват като стойности: на променливи, на параметри, в return изрази.</dt>
		</dl>
	</section>
	<section><h3>Анонимна функция като стойност на променлива (function expression)</h3>
		<pre><code rel="JS">
			var a = function(){
				console.log("I am in a!");
			}

			a();
			// "I am in a!"
		</code></pre>
		<p>Внимавайте за следната възможна грешка:</p>
		<pre><code rel="JS">
			var a = function b(){
				console.log("I am in b!");
			}

			b(); //  ReferenceError: b is not defined
		</code></pre>
	</section>
	<section style="font-size: .9em"><h3 class="advanced">IIFE</h3>
		<dl class="fa">
			<dt>Единственият начин да се изпълни анонимна функция, която не е присвоена на променлива, е чрез конструкта, наречен <span class="note">IIFE</span> (Immediately Invoked Function Expression)</dt>
		</dl>
		<pre><code rel="Syntax" class="javascript" data-noescape>
			<b>(</b>f(){}<b>)()</b>
		</code></pre>
		<pre><code rel="JS">
			(function(){
				console.log("I am in nowhere, but I exist and work!");
			})();

			// "I am in nowhere, but I exist and work"
		</code></pre>
		<dl class="fa">
			<dt>Обърнете внимание на кръглите скоби с който заграждаме декларацията на функцията (за да я превърнем в изпълним израз), както и на скобите след това, за да изпълним този израз.</dt>
		</dl>
	</section>
	<section><h3 class="advanced">IIFE</h3>
		<dl class="fa">
			<dt>IIFE намира приложение за създаване на local scope в даден скрипт.</dt>
			<pre style="width:110%"><code rel="IIFE.js" class="js">
				(function(){
					// нито една от променливите създадени чрез var или let, няма да бъде видима извън тази функция:

					var x = 42;
					console.log(`x in IIFE.js: ${x}`);
				})()
			</code></pre>
			<pre style="width:110%"><code rel="index.html" class="html">
				<script type="text/javascript" src="IIFE.js"></script>
				<script type="text/javascript">
					console.log(`x in main: ${x}`);
				</script>
			</code></pre>
		</dl>
	</section>
</section>

<section><h1>Variables Hoisting</h1></section>
<section id="Hoisting"><h2>Variables Hoisting</h2>
	<section>
		<dl class="fa">
			<dt>Декларирането на променливите <span class="note">в даден scope </span> винаги се изпълнява <span class="note">преди</span> всички изрази, без значение къде във scope се намират декларациите. </dt>
			<dt>2 паса:</dt>
			<dd>Compile time = > декларации</dd>
			<dd>Run time = > изпълнение на програмата</dd>
			<!-- <dt>Тоест, декларациите на променливите се "издигат" (hoist) до началото на съответния scope, без значение къде сме ги написали!</dt>
			<dt>Това поведение на JavaScript е в сила само за <span class="note">декларациите</span> на променливи, зададени с <span class="note">var</span> и <span class="note">function declaration</span>. Изразите се изпълняват последователно, така както сме ги написали в кода.</dt>
			<dt><span class="note">При декларация на променлива с <b>let</b> или <b>const</b> не се извършва hoisting.</span></dt> -->

		</dl>
	</section>
	<section>
		<pre><code rel="JS">
			// JavaScript "знае" за съществуването на x, тъй като декларацията "var x;" вече се е изпълнила! Но не и израза, чрез който записваме 10 в x.

			console.log("x:", x); // undefined

			var x;
			x = 10;
		</code></pre>
		<pre><code rel="JS">
			// Примерът е аналогичен на горния!
			console.log("x:", x); // undefined

			var x = 10; // тук имаме декларация, която се е изпълнила в началото и израз, който се изпълнява сега.
		</code></pre>
	</section>
	<section><h3>Function Declaration vs. Function Expression</h3>
		<dl class="fa">
			<dt>Когато дефинираме функция чрез декларация (<a href="../../../../pages/themes/beginners/JS_Functions/JS_Functions.html#/3">Вариант 1</a>) то декларацията на функцията винаги се извършва в началото на scope.</dt>
		</dl>
		<pre><code rel="JS">
			// foo() вече е декларирана и JS знае, че е функция!
			console.log( foo() );

			function foo() {
				return "I am foo() and I work!";
			}
		</code></pre>
	</section>
	<section><h3>Function Declaration vs. Function Expression</h3>
		<pre><code rel="JS">
			// foo() вече е декларирана, но JS не знае все още че е функция!
			console.log( foo() ); //TypeError: foo is not a function

			var foo = function(){
				return "I am foo() and I work!";
			}
		</code></pre>
	</section>
</section>

<section><h1>First-class functions</h1></section>
<section><h2 class="advanced">First-class functions</h2>
	<section>
		<dl class="fa">
			<dt>Свойството на функциите в JavaScript (анонимни или не) - да бъдат използвани като стойности, т.е. да бъдат записвани в промеливи, да бъдат подавани като аргументи на функции или да бъдат връщани като резултат от функция, ги определя като <span class="note">first-class functions</span></dt>
			<dt>Темата за "first-class functions" се разглежда задълбочено в <a href="https://progressbg.net/javascript-advanced-with-reactjs/">WebDesign/Front-End Dev - Advanced</a> курса. Но преди да навлезете в тази изключително важна за JavaScript тема е необходимо да усвоите добре основните, разгледани досега.</dt>
		</dl>
	</section>
	<section><h3>Функция като стойност на параметър (callback functions)</h3>
		<dl class="fa">
			<dt>Често в JavaScript се налага дадена функция да бъде подадена като аргумент на друга функция, за да бъде изпълнена от тази функция:</dt>
			<pre><code rel="JS" class="js">
				function caller(callback){
					console.log("caller will call the callback:")
					callback();
				}

				function callback1(){
					console.log("I'm the callback1 function!")
				}

				function callback2(){
					console.log("I'm the callback2 function!")
				}


				caller(callback1);
				caller(callback2);
			</code></pre>
		</dl>
	</section>
	<section><h3>example</h3>
		<dl class="fa">
			<dt>Забележете разликата при подаването на функция като параметър и подаването на резултата от функцията като параметър.</dt>
		</dl>
		<pre style="width: 110%; font-size: .5em;"><code rel="JS" class="js">
			function caller(f){
				console.log("1")
				f();
			}

			function callback(){
				console.log("2")
			}

			console.log("Feeding the caller() with function declaration")
			caller( callback );

			console.log("Feeding the caller() with function execution")
			caller( callback() );
		</code></pre>
	</section>
	<section><h3>Функция като return value</h3>
		<pre><code rel="JS" class="js">
			function foo(){
				return function(){
					console.log(`I'm the returned function`);
				}
			}

			foo()();

			// foo()() е концептуално еквивалентно на:
			// var bar = foo();
			// bar();
		</code></pre>
	</section>
	<section id="References"><h3>References</h3>
		<iframe src="https://www.youtube.com/embed/hRJrp17WnOE?list=PL-BwA4EWrxLAL9XzwMwLY2uLQFm68fJ4Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
	</section>
</section>

<section data-min="5"><h1>Примери и Задачи</h1></section>
<section><h2>Примери и Задачи</h2>
	<section><h3>Function Definitions Examples</h3>
		<iframe height="300" style="width: 100%;" scrolling="no" title="Function Definitions" src="https://codepen.io/webdesigncourse/embed/LWyPvy?height=300&theme-id=20230&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
		  See the Pen <a href='https://codepen.io/webdesigncourse/pen/LWyPvy'>Function Definitions</a> by Iva Popova
		  (<a href='https://codepen.io/webdesigncourse'>@webdesigncourse</a>) on <a href='https://codepen.io'>CodePen</a>.
		</iframe>
	</section>
	<section><h3>JS variables shadowing</h3>
		<iframe height="300" style="width: 100%;" scrolling="no" title="Scope &amp; Shadowing" src="https://codepen.io/webdesigncourse/embed/PpmYMd?height=300&theme-id=20230&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
		  See the Pen <a href='https://codepen.io/webdesigncourse/pen/PpmYMd'>Scope &amp; Shadowing</a> by Iva Popova
		  (<a href='https://codepen.io/webdesigncourse'>@webdesigncourse</a>) on <a href='https://codepen.io'>CodePen</a>.
		</iframe>
	</section>
	<section><h3>JS variables shadowing</h3>
		<iframe height="300" style="width: 100%;" scrolling="no" title="JS variables shadowing" src="https://codepen.io/webdesigncourse/embed/vxZjaq?height=300&theme-id=20230&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
		  See the Pen <a href='https://codepen.io/webdesigncourse/pen/vxZjaq'>JS variables shadowing</a> by Iva Popova
		  (<a href='https://codepen.io/webdesigncourse'>@webdesigncourse</a>) on <a href='https://codepen.io'>CodePen</a>.
		</iframe>
	</section>
	<section><h3>gameBoardDataStructure</h3>
		<iframe height="300" style="width: 100%;" scrolling="no" title="gameBoardDataStructure" src="https://codepen.io/webdesigncourse/embed/vmydQN?height=300&theme-id=20230&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
		  See the Pen <a href='https://codepen.io/webdesigncourse/pen/vmydQN'>gameBoardDataStructure</a> by Iva Popova
		  (<a href='https://codepen.io/webdesigncourse'>@webdesigncourse</a>) on <a href='https://codepen.io'>CodePen</a>.
		</iframe>
	</section>
	<section><h3>getHigherScoreIndex</h3>
		<iframe height="300" style="width: 100%;" scrolling="no" title="HW: Max/Min student score" src="https://codepen.io/webdesigncourse/embed/wRRaej?height=300&theme-id=20230&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
		  See the Pen <a href='https://codepen.io/webdesigncourse/pen/wRRaej'>HW: Max/Min student score</a> by Iva Popova
		  (<a href='https://codepen.io/webdesigncourse'>@webdesigncourse</a>) on <a href='https://codepen.io'>CodePen</a>.
	  </iframe>
	</section>
	<section><h3>SumEven2DimArrayElements</h3>
		<iframe height="300" style="width: 100%;" scrolling="no" title="HW: SumEvenArrayElements" src="https://codepen.io/webdesigncourse/embed/rPOXBe?height=300&theme-id=20230&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
		See the Pen <a href='https://codepen.io/webdesigncourse/pen/rPOXBe'>HW: SumEvenArrayElements</a> by Iva Popova
		(<a href='https://codepen.io/webdesigncourse'>@webdesigncourse</a>) on <a href='https://codepen.io'>CodePen</a>.
		</iframe>
	</section>
	<section><h3>autoChangeColor</h3>
		<iframe height="300" style="width: 100%;" scrolling="no" title="autoChangeColor" src="https://codepen.io/webdesigncourse/embed/qmWPdJ?height=300&theme-id=20230&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
		  See the Pen <a href='https://codepen.io/webdesigncourse/pen/qmWPdJ'>autoChangeColor</a> by Iva Popova
		  (<a href='https://codepen.io/webdesigncourse'>@webdesigncourse</a>) on <a href='https://codepen.io'>CodePen</a>.
		</iframe>
	</section>


  <section><h3>Всички примери в codepen:</h3>
	<a href="http://codepen.io/collection/DwWyQw/">codepen колекция с примери и задачи върху темата</a>
  </section>
</section>


<section class="disclaimer" data-background="../../../../outfit/images/for_slides/the_end_on_sand.jpg">
	 <p>These slides are based on</p>
	 <p>customised version of </p>
	 <p><a href="http://hakim.se/">Hakimel</a>'s <a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
	 <p>framework</p>
</section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
		</div>
	</div>
	<!-- Custom processing -->
	<script src="../../../../outfit/js/slides.js"></script>
	<!-- external scripts -->

	<script src="../../../../lib/reveal.js/js/reveal.js"></script>
	<!-- init reveal -->
	<script>
		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		var highlightjsTabSize = '  ';
		Reveal.initialize({
			controls: true,
			progress: true,
			slideNumber: 'c/t',
			keyboard: true,
			history: true,
			center: true,
			width: 1024,
			height: 850,
			// Bounds for smallest/largest possible scale to apply to content
			// minScale: .5,
			maxScale: 1,
			// slide transition
			transition: 'concave', // none/fade/slide/convex/concave/zoom
			// Factor of the display size that should remain empty around the content
			margin: 0.1,
			// shift+maous click to zoom in/out element
			zoomKey: 'ctrl',
			// theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			// transition: Reveal.getQueryHash().transition || 'default'
			// Optional reveal.js plugins
			dependencies: [
				{ src: '../../../../lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: '../../../../lib/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '../../../../lib/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '../../../../lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({tabReplace: highlightjsTabSize}); hljs.initHighlightingOnLoad(); } },
				{ src: '../../../../lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
				{ src: '../../../../lib/reveal.js/plugin/notes/notes.js', async: true }
			]
		});
	</script>
	<!-- linkedin badge -->
	<script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>
</body>
</html>
